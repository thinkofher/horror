// Code generated by go generate; DO NOT EDIT.
// This file was generated at:
// 2021-03-26 13:37:49.465206211 &#43;0100 CET m=&#43;0.000693748
package horror

import (
	"bytes"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/thinkofher/horror/status"
)

func statusErrorFunc(body []byte, f func([]byte) *status.Status) Handler {
	return HandlerFunc(func(w http.ResponseWriter, r *http.Request) error {
		return f(body)
	})
}

func TestHTTPErrorFuncs(t *testing.T) {
	tests := []struct {
		name     string
		factory  func([]byte) *status.Status
		wantCode int
	}{
		{
			name:     "BadRequest",
			factory:  status.BadRequest,
			wantCode: http.StatusBadRequest,
		},
		{
			name:     "Unauthorized",
			factory:  status.Unauthorized,
			wantCode: http.StatusUnauthorized,
		},
		{
			name:     "PaymentRequired",
			factory:  status.PaymentRequired,
			wantCode: http.StatusPaymentRequired,
		},
		{
			name:     "Forbidden",
			factory:  status.Forbidden,
			wantCode: http.StatusForbidden,
		},
		{
			name:     "NotFound",
			factory:  status.NotFound,
			wantCode: http.StatusNotFound,
		},
		{
			name:     "MethodNotAllowed",
			factory:  status.MethodNotAllowed,
			wantCode: http.StatusMethodNotAllowed,
		},
		{
			name:     "NotAcceptable",
			factory:  status.NotAcceptable,
			wantCode: http.StatusNotAcceptable,
		},
		{
			name:     "ProxyAuthRequired",
			factory:  status.ProxyAuthRequired,
			wantCode: http.StatusProxyAuthRequired,
		},
		{
			name:     "RequestTimeout",
			factory:  status.RequestTimeout,
			wantCode: http.StatusRequestTimeout,
		},
		{
			name:     "Conflict",
			factory:  status.Conflict,
			wantCode: http.StatusConflict,
		},
		{
			name:     "Gone",
			factory:  status.Gone,
			wantCode: http.StatusGone,
		},
		{
			name:     "LengthRequired",
			factory:  status.LengthRequired,
			wantCode: http.StatusLengthRequired,
		},
		{
			name:     "PreconditionFailed",
			factory:  status.PreconditionFailed,
			wantCode: http.StatusPreconditionFailed,
		},
		{
			name:     "RequestEntityTooLarge",
			factory:  status.RequestEntityTooLarge,
			wantCode: http.StatusRequestEntityTooLarge,
		},
		{
			name:     "RequestURITooLong",
			factory:  status.RequestURITooLong,
			wantCode: http.StatusRequestURITooLong,
		},
		{
			name:     "UnsupportedMediaType",
			factory:  status.UnsupportedMediaType,
			wantCode: http.StatusUnsupportedMediaType,
		},
		{
			name:     "RequestedRangeNotSatisfiable",
			factory:  status.RequestedRangeNotSatisfiable,
			wantCode: http.StatusRequestedRangeNotSatisfiable,
		},
		{
			name:     "ExpectationFailed",
			factory:  status.ExpectationFailed,
			wantCode: http.StatusExpectationFailed,
		},
		{
			name:     "Teapot",
			factory:  status.Teapot,
			wantCode: http.StatusTeapot,
		},
		{
			name:     "MisdirectedRequest",
			factory:  status.MisdirectedRequest,
			wantCode: http.StatusMisdirectedRequest,
		},
		{
			name:     "UnprocessableEntity",
			factory:  status.UnprocessableEntity,
			wantCode: http.StatusUnprocessableEntity,
		},
		{
			name:     "Locked",
			factory:  status.Locked,
			wantCode: http.StatusLocked,
		},
		{
			name:     "FailedDependency",
			factory:  status.FailedDependency,
			wantCode: http.StatusFailedDependency,
		},
		{
			name:     "TooEarly",
			factory:  status.TooEarly,
			wantCode: http.StatusTooEarly,
		},
		{
			name:     "UpgradeRequired",
			factory:  status.UpgradeRequired,
			wantCode: http.StatusUpgradeRequired,
		},
		{
			name:     "PreconditionRequired",
			factory:  status.PreconditionRequired,
			wantCode: http.StatusPreconditionRequired,
		},
		{
			name:     "TooManyRequests",
			factory:  status.TooManyRequests,
			wantCode: http.StatusTooManyRequests,
		},
		{
			name:     "RequestHeaderFieldsTooLarge",
			factory:  status.RequestHeaderFieldsTooLarge,
			wantCode: http.StatusRequestHeaderFieldsTooLarge,
		},
		{
			name:     "UnavailableForLegalReasons",
			factory:  status.UnavailableForLegalReasons,
			wantCode: http.StatusUnavailableForLegalReasons,
		},
		{
			name:     "InternalServerError",
			factory:  status.InternalServerError,
			wantCode: http.StatusInternalServerError,
		},
		{
			name:     "NotImplemented",
			factory:  status.NotImplemented,
			wantCode: http.StatusNotImplemented,
		},
		{
			name:     "BadGateway",
			factory:  status.BadGateway,
			wantCode: http.StatusBadGateway,
		},
		{
			name:     "ServiceUnavailable",
			factory:  status.ServiceUnavailable,
			wantCode: http.StatusServiceUnavailable,
		},
		{
			name:     "GatewayTimeout",
			factory:  status.GatewayTimeout,
			wantCode: http.StatusGatewayTimeout,
		},
		{
			name:     "HTTPVersionNotSupported",
			factory:  status.HTTPVersionNotSupported,
			wantCode: http.StatusHTTPVersionNotSupported,
		},
		{
			name:     "VariantAlsoNegotiates",
			factory:  status.VariantAlsoNegotiates,
			wantCode: http.StatusVariantAlsoNegotiates,
		},
		{
			name:     "InsufficientStorage",
			factory:  status.InsufficientStorage,
			wantCode: http.StatusInsufficientStorage,
		},
		{
			name:     "LoopDetected",
			factory:  status.LoopDetected,
			wantCode: http.StatusLoopDetected,
		},
		{
			name:     "NotExtended",
			factory:  status.NotExtended,
			wantCode: http.StatusNotExtended,
		},
		{
			name:     "NetworkAuthenticationRequired",
			factory:  status.NetworkAuthenticationRequired,
			wantCode: http.StatusNetworkAuthenticationRequired,
		},
	}

	for _, tt := range tests {
		t.Run(
			fmt.Sprintf("Requesting handler which returns only %s status.", tt.name),
			func(t *testing.T) {
				req, err := http.NewRequest(http.MethodGet, "/", nil)
				if err != nil {
					t.Errorf("got unwanted error: %v", err)
				}

				body := []byte(tt.name + " test")
				mux := http.NewServeMux()
				mux.Handle("/", WithError(statusErrorFunc(body, tt.factory)))
				rr := httptest.NewRecorder()
				mux.ServeHTTP(rr, req)

				if tt.wantCode != rr.Code {
					t.Errorf("got: %d, want: %d", rr.Code, tt.wantCode)
				}

				if !bytes.Equal(body, rr.Body.Bytes()) {
					t.Errorf("got: b\"%s\", want: b\"%s\"", body, rr.Body.Bytes())
				}
			},
		)
		t.Run(
			fmt.Sprintf("Requesting handler which returns only %s status with adapter.",
				tt.name),
			func(t *testing.T) {
				req, err := http.NewRequest(http.MethodGet, "/", nil)
				if err != nil {
					t.Errorf("got unwanted error: %v", err)
				}

				adapter := NewAdapter(&AdapterBuilder{})

				body := []byte(tt.name + " test")
				mux := http.NewServeMux()
				mux.Handle("/", adapter.WithError(statusErrorFunc(body, tt.factory)))
				rr := httptest.NewRecorder()
				mux.ServeHTTP(rr, req)

				if tt.wantCode != rr.Code {
					t.Errorf("got: %d, want: %d", rr.Code, tt.wantCode)
				}

				if !bytes.Equal(body, rr.Body.Bytes()) {
					t.Errorf("got: b\"%s\", want: b\"%s\"", body, rr.Body.Bytes())
				}
			},
		)
	}
}
