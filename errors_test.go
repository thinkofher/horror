// Code generated by go generate; DO NOT EDIT.
// This file was generated at:
// 2021-03-25 17:00:48.372188381 &#43;0100 CET m=&#43;0.000906358
package horror

import (
	"bytes"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
)

func statusErrorFunc(body []byte, f func([]byte) Error) Handler {
	return HandlerFunc(func(w http.ResponseWriter, r *http.Request) error {
		return f(body)
	})
}

func TestHTTPErrorFuncs(t *testing.T) {
	tests := []struct {
		name     string
		factory  func([]byte) Error
		wantCode int
	}{
		{
			name:     "BadRequest",
			factory:  BadRequest,
			wantCode: http.StatusBadRequest,
		},
		{
			name:     "Unauthorized",
			factory:  Unauthorized,
			wantCode: http.StatusUnauthorized,
		},
		{
			name:     "PaymentRequired",
			factory:  PaymentRequired,
			wantCode: http.StatusPaymentRequired,
		},
		{
			name:     "Forbidden",
			factory:  Forbidden,
			wantCode: http.StatusForbidden,
		},
		{
			name:     "NotFound",
			factory:  NotFound,
			wantCode: http.StatusNotFound,
		},
		{
			name:     "MethodNotAllowed",
			factory:  MethodNotAllowed,
			wantCode: http.StatusMethodNotAllowed,
		},
		{
			name:     "NotAcceptable",
			factory:  NotAcceptable,
			wantCode: http.StatusNotAcceptable,
		},
		{
			name:     "ProxyAuthRequired",
			factory:  ProxyAuthRequired,
			wantCode: http.StatusProxyAuthRequired,
		},
		{
			name:     "RequestTimeout",
			factory:  RequestTimeout,
			wantCode: http.StatusRequestTimeout,
		},
		{
			name:     "Conflict",
			factory:  Conflict,
			wantCode: http.StatusConflict,
		},
		{
			name:     "Gone",
			factory:  Gone,
			wantCode: http.StatusGone,
		},
		{
			name:     "LengthRequired",
			factory:  LengthRequired,
			wantCode: http.StatusLengthRequired,
		},
		{
			name:     "PreconditionFailed",
			factory:  PreconditionFailed,
			wantCode: http.StatusPreconditionFailed,
		},
		{
			name:     "RequestEntityTooLarge",
			factory:  RequestEntityTooLarge,
			wantCode: http.StatusRequestEntityTooLarge,
		},
		{
			name:     "RequestURITooLong",
			factory:  RequestURITooLong,
			wantCode: http.StatusRequestURITooLong,
		},
		{
			name:     "UnsupportedMediaType",
			factory:  UnsupportedMediaType,
			wantCode: http.StatusUnsupportedMediaType,
		},
		{
			name:     "RequestedRangeNotSatisfiable",
			factory:  RequestedRangeNotSatisfiable,
			wantCode: http.StatusRequestedRangeNotSatisfiable,
		},
		{
			name:     "ExpectationFailed",
			factory:  ExpectationFailed,
			wantCode: http.StatusExpectationFailed,
		},
		{
			name:     "Teapot",
			factory:  Teapot,
			wantCode: http.StatusTeapot,
		},
		{
			name:     "MisdirectedRequest",
			factory:  MisdirectedRequest,
			wantCode: http.StatusMisdirectedRequest,
		},
		{
			name:     "UnprocessableEntity",
			factory:  UnprocessableEntity,
			wantCode: http.StatusUnprocessableEntity,
		},
		{
			name:     "Locked",
			factory:  Locked,
			wantCode: http.StatusLocked,
		},
		{
			name:     "FailedDependency",
			factory:  FailedDependency,
			wantCode: http.StatusFailedDependency,
		},
		{
			name:     "TooEarly",
			factory:  TooEarly,
			wantCode: http.StatusTooEarly,
		},
		{
			name:     "UpgradeRequired",
			factory:  UpgradeRequired,
			wantCode: http.StatusUpgradeRequired,
		},
		{
			name:     "PreconditionRequired",
			factory:  PreconditionRequired,
			wantCode: http.StatusPreconditionRequired,
		},
		{
			name:     "TooManyRequests",
			factory:  TooManyRequests,
			wantCode: http.StatusTooManyRequests,
		},
		{
			name:     "RequestHeaderFieldsTooLarge",
			factory:  RequestHeaderFieldsTooLarge,
			wantCode: http.StatusRequestHeaderFieldsTooLarge,
		},
		{
			name:     "UnavailableForLegalReasons",
			factory:  UnavailableForLegalReasons,
			wantCode: http.StatusUnavailableForLegalReasons,
		},
		{
			name:     "InternalServerError",
			factory:  InternalServerError,
			wantCode: http.StatusInternalServerError,
		},
		{
			name:     "NotImplemented",
			factory:  NotImplemented,
			wantCode: http.StatusNotImplemented,
		},
		{
			name:     "BadGateway",
			factory:  BadGateway,
			wantCode: http.StatusBadGateway,
		},
		{
			name:     "ServiceUnavailable",
			factory:  ServiceUnavailable,
			wantCode: http.StatusServiceUnavailable,
		},
		{
			name:     "GatewayTimeout",
			factory:  GatewayTimeout,
			wantCode: http.StatusGatewayTimeout,
		},
		{
			name:     "HTTPVersionNotSupported",
			factory:  HTTPVersionNotSupported,
			wantCode: http.StatusHTTPVersionNotSupported,
		},
		{
			name:     "VariantAlsoNegotiates",
			factory:  VariantAlsoNegotiates,
			wantCode: http.StatusVariantAlsoNegotiates,
		},
		{
			name:     "InsufficientStorage",
			factory:  InsufficientStorage,
			wantCode: http.StatusInsufficientStorage,
		},
		{
			name:     "LoopDetected",
			factory:  LoopDetected,
			wantCode: http.StatusLoopDetected,
		},
		{
			name:     "NotExtended",
			factory:  NotExtended,
			wantCode: http.StatusNotExtended,
		},
		{
			name:     "NetworkAuthenticationRequired",
			factory:  NetworkAuthenticationRequired,
			wantCode: http.StatusNetworkAuthenticationRequired,
		},
	}

	for _, tt := range tests {
		t.Run(
			fmt.Sprintf("Requesting handler which returns only %s status.", tt.name),
			func(t *testing.T) {
				req, err := http.NewRequest(http.MethodGet, "/", nil)
				if err != nil {
					t.Errorf("got unwanted error: %v", err)
				}

				body := []byte(tt.name + " test")
				mux := http.NewServeMux()
				mux.Handle("/", WithError(statusErrorFunc(body, tt.factory)))
				rr := httptest.NewRecorder()
				mux.ServeHTTP(rr, req)

				if tt.wantCode != rr.Code {
					t.Errorf("got: %d, want: %d", rr.Code, tt.wantCode)
				}

				if !bytes.Equal(body, rr.Body.Bytes()) {
					t.Errorf("got: b\"%s\", want: b\"%s\"", body, rr.Body.Bytes())
				}
			})
	}
}
